### 调用appendChild()时,传入这个方法的节点到底在哪里?
appendChild()会把这个节点作为父元素的最后一个子节点

### 如果我不想让这个新节点作为最后一个子节点呢?

可以使用insertBefore()方法,要向insertBefore-re()传入两个节点,一个是增加节点,另一个是现有的节点,新节点将插到该节点之前

### 上一章中不是使用appendChild()来移动元素?

appendChild()或insertBefore-re()传入什么节点,它都将作为一个新的子节点调用到appendChild()的父节点上,如果该节点已经在DOM树上中,浏览器就会移动到这个节点,或者如果该节点尚未作为树中的一部分,浏览器则会把这个节点增加到DOM树中

### 如果一个节点已经有自己的子节点,z在追加或插入这个节点会发生什么?

浏览器会把你插入的元素以及他的所有子元素都插入到DOM树中,所以移动一个节点时,实际上移动了这个节点以及DOM树中该节点以下的所有节点

### 能不能从DOM树删除一个节点?
当然可以,可以使用removeNode()方法从DOM树完全删除一个节点

### childNodes属性是什么?
childNodes是每个节点都有的一个属性,它返回该节点所有子节点的一个数组,如果这个节点没有任何子节点,则返回null,由于这是一个数组,所以它有一个length属性,可以指出数组中有多少个节点

### 难道不恩能够跟踪是否调用了addLetter()并以此做出条件?

不行,这样并不能总能奏效,第一次调用addLetter()时,确实需要创建一个p和文本节点,但是如果玩家提交了一个单词,而且盘面重置,则需要addLetter()再次创建一个新的p和文本节点,所以只是检查运行了多少次addletter()还不够

### 由你控制DOM结构时,不会发生你未曾指定的事情

浏览器根据一个XHTML文本文件创建DOM树时,将由浏览器控制着一起,浏览器会做它认为最适合表示的XHTML的事情,当你对DOM树进行修改时,一切由你来控制,浏览器不会插入任何东西,除非你告诉它那么做,所以处理你插入到currentWorld,div的DOM节点时,不用担心额外的空白文本节点,实际上,你完全可以获取div的第一个子节点,而且清楚地知道这是一个`p`

### 并不是所有的请求都必须是异步请求

我们建立的都是异步请求,所以用户不必等待口令检查或页面加载

### 同步请求不需要回调函数
如果请求是异步的,浏览器会继续运行你的代码,所以在运行request.send(null),浏览器会执行发送函数之后的下一行代码,这往往就是函数的最后,因为我们希望用户能继续处理web页面,然后当服务器响应时,会运行一个回调,这可能会更新页面,或者对服务器返回的结果做出响应
但是对于一个同步请求,浏览器就会等待服务器完成工作,在服务器返回一个响应之前不会运行其他代码,所以在这种情况下,我们确实不需要一个回调函数,可以在发送函数中继续做其他的工作,而且我们知道`请求对象中包含服务器的所有响应数据


### css定位?

css定位就是指,不依赖于XHTML的结构来完成页面上元素的定位,而使用css,所以,如果希望对一个a元素完成css定位,要为该元素指定一类id,再在css中设置left,right,top,或者bottom属性,或者使用position和float css属性

